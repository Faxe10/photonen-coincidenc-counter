<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time System Value Plotter</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            background: linear-gradient(45deg, #fff, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
        }

        .control-group label {
            font-weight: 600;
            white-space: nowrap;
        }

        .checkbox-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-weight: 600;
        }

        .checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .trace-a { color: #FF6B6B; }
        .trace-b { color: #4ECDC4; }
        .trace-sum { color: #45B7D1; }

        select, input {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 14px;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }

        .btn-tertiary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .current-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .value-display {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .value-label {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .value-number {
            font-size: 24px;
            font-weight: bold;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .status.connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .status.simulating {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
        }

        canvas {
            width: 100%;
            height: 400px;
            background: white;
            border-radius: 10px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: space-between;
            }

            .buttons {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Real-time System Value Plotter</h1>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Show Traces:</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showValueA" checked>
                        <span class="trace-a">Value A</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="showValueB" checked>
                        <span class="trace-b">Value B</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="showSum" checked>
                        <span class="trace-sum">Sum (A+B)</span>
                    </label>
                </div>
            </div>

            <div class="control-group">
                <label for="maxPoints">Max Points:</label>
                <input type="number" id="maxPoints" min="10" max="10000" value="100" step="10">
            </div>

            <div class="control-group">
                <label for="updateRate">Update Rate (ms):</label>
                <input type="number" id="updateRate" min="50" max="5000" value="100" step="50">
            </div>

            <div class="buttons">
                <button class="btn btn-primary" id="connectBtn">Connect to Python</button>
                <button class="btn btn-secondary" id="simulateBtn">Start Simulation</button>
                <button class="btn btn-tertiary" id="clearBtn">Clear Data</button>
                <button class="btn btn-primary" id="pauseBtn">Pause</button>
                <button class="btn btn-secondary" id="exportBtn">Export Data</button>
            </div>
        </div>

        <div id="status" class="status disconnected">
            Disconnected - Click "Connect to Python" or "Start Simulation" to begin
        </div>

        <div class="current-values">
            <div class="value-display" id="value0">
                <div class="value-label">Value A</div>
                <div class="value-number" id="valueA">-</div>
            </div>
            <div class="value-display" id="value1">
                <div class="value-label">Value B</div>
                <div class="value-number" id="valueB">-</div>
            </div>
            <div class="value-display" id="value2">
                <div class="value-label">Sum (A+B)</div>
                <div class="value-number" id="valueSum">-</div>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="chart"></canvas>
        </div>
    </div>

    <script>
        class RealTimePlotter {
            constructor() {
                this.canvas = document.getElementById('chart');
                this.ctx = this.canvas.getContext('2d');
                this.data = [];
                this.maxPoints = 100;
                this.showTraces = [true, true, true]; // A, B, Sum
                this.isSimulating = false;
                this.isPaused = false;
                this.simulationInterval = null;
                this.animationId = null;
                this.websocket = null;
                this.updateRate = 100;

                this.setupCanvas();
                this.setupEventListeners();
                this.startAnimation();
            }

            setupCanvas() {
                this.canvas.width = this.canvas.offsetWidth * window.devicePixelRatio;
                this.canvas.height = this.canvas.offsetHeight * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            setupEventListeners() {
                // Checkbox event listeners
                document.getElementById('showValueA').addEventListener('change', (e) => {
                    this.showTraces[0] = e.target.checked;
                    this.draw();
                });

                document.getElementById('showValueB').addEventListener('change', (e) => {
                    this.showTraces[1] = e.target.checked;
                    this.draw();
                });

                document.getElementById('showSum').addEventListener('change', (e) => {
                    this.showTraces[2] = e.target.checked;
                    this.draw();
                });

                document.getElementById('maxPoints').addEventListener('change', (e) => {
                    this.maxPoints = parseInt(e.target.value);
                    this.trimData();
                    this.draw();
                });

                document.getElementById('updateRate').addEventListener('change', (e) => {
                    this.updateRate = parseInt(e.target.value);
                    if (this.isSimulating) {
                        this.stopSimulation();
                        this.startSimulation();
                    }
                });

                document.getElementById('connectBtn').addEventListener('click', () => {
                    this.connectToPython();
                });

                document.getElementById('simulateBtn').addEventListener('click', () => {
                    this.toggleSimulation();
                });

                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearData();
                });

                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.togglePause();
                });

                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportData();
                });

                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.draw();
                });
            }

            connectToPython() {
                const status = document.getElementById('status');

                if (this.websocket) {
                    this.websocket.close();
                }

                status.textContent = 'Connecting to Python script...';
                status.className = 'status';

                try {
                    this.websocket = new WebSocket('ws://localhost:8080');

                    this.websocket.onopen = () => {
                        status.textContent = 'Connected to Python script';
                        status.className = 'status connected';
                        console.log('WebSocket connected');
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const values = event.data.trim().split(/\s+/).map(Number);
                            if (values.length >= 3) {
                                this.addDataPoint([values[0], values[1], values[2]]);
                            }
                        } catch (error) {
                            console.error('Error parsing data:', error);
                        }
                    };

                    this.websocket.onclose = (event) => {
                        status.textContent = 'Connection closed';
                        status.className = 'status disconnected';
                        console.log('WebSocket closed:', event);
                        this.websocket = null;
                    };

                    this.websocket.onerror = (error) => {
                        status.textContent = 'Connection failed - Check if Python script is running';
                        status.className = 'status disconnected';
                        console.error('WebSocket error:', error);
                        this.websocket = null;
                    };

                } catch (error) {
                    status.textContent = 'Failed to connect - Use simulation mode';
                    status.className = 'status disconnected';
                    console.error('Connection error:', error);
                }
            }

            toggleSimulation() {
                const btn = document.getElementById('simulateBtn');
                const status = document.getElementById('status');

                if (this.isSimulating) {
                    this.stopSimulation();
                    btn.textContent = 'Start Simulation';
                    btn.className = 'btn btn-secondary';
                    status.textContent = 'Simulation stopped';
                    status.className = 'status disconnected';
                } else {
                    this.startSimulation();
                    btn.textContent = 'Stop Simulation';
                    btn.className = 'btn btn-secondary';
                    status.textContent = 'Simulation running';
                    status.className = 'status simulating';
                }
            }

            startSimulation() {
                this.isSimulating = true;
                this.simulationInterval = setInterval(() => {
                    const a = Math.floor(Math.random() * 100000);
                    const b = Math.floor(Math.random() * 100000);
                    const sum = a + b;
                    this.addDataPoint([a, b, sum]);
                }, this.updateRate);
            }

            stopSimulation() {
                this.isSimulating = false;
                if (this.simulationInterval) {
                    clearInterval(this.simulationInterval);
                    this.simulationInterval = null;
                }
            }

            togglePause() {
                const btn = document.getElementById('pauseBtn');
                this.isPaused = !this.isPaused;

                if (this.isPaused) {
                    btn.textContent = 'Resume';
                    btn.className = 'btn btn-primary';
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                } else {
                    btn.textContent = 'Pause';
                    btn.className = 'btn btn-primary';
                    this.startAnimation();
                }
            }

            exportData() {
                if (this.data.length === 0) {
                    alert('No data to export');
                    return;
                }

                const csvContent = "data:text/csv;charset=utf-8,"
                    + "Timestamp,Value A,Value B,Sum\n"
                    + this.data.map(row => {
                        const date = new Date(row.time);
                        return `${date.toISOString()},${row.values[0]},${row.values[1]},${row.values[2]}`;
                    }).join('\n');

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", `realtime_data_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            addDataPoint(values) {
                if (this.isPaused) return;

                const timestamp = Date.now();
                this.data.push({
                    time: timestamp,
                    values: values
                });

                this.trimData();
                this.updateCurrentValues(values);
            }

            trimData() {
                while (this.data.length > this.maxPoints) {
                    this.data.shift();
                }
            }

            updateCurrentValues(values) {
                document.getElementById('valueA').textContent = values[0].toLocaleString();
                document.getElementById('valueB').textContent = values[1].toLocaleString();
                document.getElementById('valueSum').textContent = values[2].toLocaleString();
            }

            clearData() {
                this.data = [];
                document.getElementById('valueA').textContent = '-';
                document.getElementById('valueB').textContent = '-';
                document.getElementById('valueSum').textContent = '-';
                this.draw();
            }

            startAnimation() {
                if (this.animationId) return;

                const animate = () => {
                    if (!this.isPaused) {
                        this.draw();
                        this.animationId = requestAnimationFrame(animate);
                    }
                };
                animate();
            }

            draw() {
                const canvas = this.canvas;
                const ctx = this.ctx;
                const width = canvas.width / window.devicePixelRatio;
                const height = canvas.height / window.devicePixelRatio;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                if (this.data.length === 0) {
                    // Draw empty state
                    ctx.fillStyle = '#999';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data to display', width / 2, height / 2);
                    return;
                }

                // Calculate bounds for all visible traces
                let allValues = [];
                if (this.showTraces[0]) allValues = allValues.concat(this.data.map(d => d.values[0]));
                if (this.showTraces[1]) allValues = allValues.concat(this.data.map(d => d.values[1]));
                if (this.showTraces[2]) allValues = allValues.concat(this.data.map(d => d.values[2]));

                if (allValues.length === 0) return;

                const minValue = Math.min(...allValues);
                const maxValue = Math.max(...allValues);
                const valueRange = maxValue - minValue || 1;

                const padding = 50;
                const chartWidth = width - 2 * padding;
                const chartHeight = height - 2 * padding;

                // Draw grid
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;

                // Horizontal grid lines
                for (let i = 0; i <= 10; i++) {
                    const y = padding + (i * chartHeight / 10);
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }

                // Vertical grid lines
                for (let i = 0; i <= 10; i++) {
                    const x = padding + (i * chartWidth / 10);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, height - padding);
                    ctx.stroke();
                }

                // Draw axes
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();

                // Draw value labels
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';

                for (let i = 0; i <= 5; i++) {
                    const value = minValue + (i * valueRange / 5);
                    const y = height - padding - (i * chartHeight / 5);
                    ctx.fillText(Math.round(value).toLocaleString(), padding - 5, y + 4);
                }

                // Draw time axis labels
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';

                if (this.data.length > 1) {
                    const timeSpan = this.data[this.data.length - 1].time - this.data[0].time;
                    const labels = 5;

                    for (let i = 0; i <= labels; i++) {
                        const x = padding + (i * chartWidth / labels);
                        const timeOffset = (i / labels) * timeSpan;
                        const time = new Date(this.data[0].time + timeOffset);
                        const timeStr = time.toLocaleTimeString([], {hour12: false, minute: '2-digit', second: '2-digit'});
                        ctx.fillText(timeStr, x, height - padding + 15);
                    }
                }

                // Draw data lines for each trace
                const traceColors = ['#FF6B6B', '#4ECDC4', '#45B7D1'];
                const traceNames = ['Value A', 'Value B', 'Sum (A+B)'];

                if (this.data.length > 1) {
                    for (let traceIndex = 0; traceIndex < 3; traceIndex++) {
                        if (!this.showTraces[traceIndex]) continue;

                        ctx.strokeStyle = traceColors[traceIndex];
                        ctx.lineWidth = 2;
                        ctx.beginPath();

                        let firstPoint = true;
                        for (let i = 0; i < this.data.length; i++) {
                            const x = padding + (i * chartWidth / (this.data.length - 1));
                            const value = this.data[i].values[traceIndex];
                            const y = height - padding - ((value - minValue) / valueRange * chartHeight);

                            if (firstPoint) {
                                ctx.moveTo(x, y);
                                firstPoint = false;
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }

                        ctx.stroke();

                        // Draw data points
                        ctx.fillStyle = traceColors[traceIndex];
                        for (let i = 0; i < this.data.length; i++) {
                            const x = padding + (i * chartWidth / (this.data.length - 1));
                            const value = this.data[i].values[traceIndex];
                            const y = height - padding - ((value - minValue) / valueRange * chartHeight);

                            ctx.beginPath();
                            ctx.arc(x, y, 2, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                }

                // Draw legend
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                let legendY = 30;
                for (let i = 0; i < 3; i++) {
                    if (!this.showTraces[i]) continue;

                    ctx.fillStyle = traceColors[i];
                    ctx.fillRect(width - 150, legendY - 10, 15, 3);
                    ctx.fillText(traceNames[i], width - 130, legendY);
                    legendY += 20;
                }

                // Draw title
                ctx.fillStyle = '#333';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Real-time Multi-trace Plot', width / 2, 25);
            }
        }

        // Initialize the plotter when the page loads
        let plotter;
        window.addEventListener('load', () => {
            plotter = new RealTimePlotter();
        });
    </script>
</body>
</html>